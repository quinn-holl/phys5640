// Calculate the Voltage for a 2D system with wire at fixed voltage immediately above
// a 3-sided box at 0V

#include "TGraph2D.h"
#include "TCanvas.h"
#include "TSystem.h"
#include "TBox.h"
#include "TApplication.h"

#include <getopt.h>
#include <iostream>
#include <vector>
#include <algorithm>

using std::vector;
using std::cout;
using std::endl;

const double XBEGIN = 0.35;
const double XEND = 0.65;
const double YBEGIN = 0.45;
const double YEND = 0.55;
const double RHO = 3.33;
const double RSTART = 0.15;
const double REND = 0.25;
const double PHISTART = 0;
const double PHIEND = .062; //.062 radians
const int Mpts = 100;  


// generic code to do one iteration of finite difference method
// Jacobi Method

//Uncomment out if you want cylindircal solver 

double iterateJ(vector<vector<double>> &V, double L){
  if(V.size() == 0 || V[0].size() == 0){
    printf("Size of array is off\n");
    exit(1);
  }
  double deltaR = 2.0/(2.0*V.size()+1);
  double deltaP = 2.0*M_PI/(V[0].size());
  int rstart = int(RSTART/deltaR);
  int rend = int(REND/deltaR);
  int phiStart = int(PHISTART/deltaP);
  int phiEnd = int(PHIEND/deltaP);
  auto Vtmp = V;
  double dVmax = 1e-50;
  int nr = V.size();
  int np = V[0].size();
  for(int i = 1; i<nr-1;i++){
    for(int j = 0;j < np; j++){
      double r = (i-0.5)*deltaR;
      double V1 =  (V[i+1][j] + V[i-1][j])/(deltaR*deltaR);
      double V2 = (V[i+1][j] - V[i-1][j])/(2*deltaR*r);
      // Heed the BC for cylindrical, that theta wraps back around itself
      double V3 = (V[i][j+1] + V[i][j-1])/(deltaP*deltaP*r*r);
      if(j == 0){
	V3 = (V[i][j+1] + V[i][np-1])/(deltaP*deltaP*r*r);
      } else if (j == np-1){
	V3 = (V[i][0] + V[i][j])/(deltaP*deltaP*r*r);
      }
      double Vnew = (V1+V2+V3)/((2/(pow(deltaR,2))) + (2/(pow(deltaP*r,2))));
      double dV = fabs(Vnew-V[i][j]);
      dVmax = std::max(dVmax,dV);
      if( (j>= phiEnd || j <= phiStart) && i== rstart){
	continue; //keeping constant potential
      }
      if( (j>= phiEnd || j <= phiStart) && i == rend){
	continue; //keeping constant potential
      }
      if( j == np-1 ){  //B.C. for cylindrical coordinates
	V[i][j]  = V[i][0];
      }
      else{
	V[i][j] = Vnew;
      }
    }
  }
  return dVmax;


}

void printLattice(vector<vector<double>> &V){
  for(int i = 0; i<V.size();i++){
    for(int j = 0;j<V[0].size();j++){
      printf("%.2lf \t ",V[i][j]);
    }
    printf("\n");
  }
}



// Gauss-Seidel Method
double iterateGS(vector<vector<double>> &V){
  double dVmax=1e-50;
  int nx=V.size();
  int ny=V[0].size();
  for (int i=1; i<nx-1; i++){
    for (int j=1; j<ny-1; j++){
      double Vnew = 0.25*(V[i+1][j]+V[i-1][j]+V[i][j+1]+V[i][j-1]);
      double dV=fabs(Vnew-V[i][j]);
      dVmax=std::max(dVmax,dV);    // keep track of max change in this sweep
      V[i][j] = Vnew;
    }
  }
  return dVmax;
}

// fill a TGraph2D object from a vector of voltages
// delta: grid spacing
// the optional range parameter defines the subregion to plot



*/
//Uncomment out if you want cylindrical solver

void fillGraph(TGraph2D* tg, const vector<vector<double>> &V, double deltaR, double deltaP, TBox *range=0){
  int nx=V.size();
  int ny=V[0].size();
  tg->Clear();                 // reset the graph
  for (int i=1; i<nx; i++){
    double r = (i-0.5)*deltaR;
    for (int j=1; j<ny; j++){
      double theta = (j-1)*deltaP;
      double x = r*cos(theta);
      double y = r*sin(theta);
      printf("%lf: x    %lf:  y, %lf   value\n",x,y,V[i][j]);
      tg->SetPoint(tg->GetN(),x,y,V[i][j]);
    }
  }
}

TGraph2D* LaplaceLine(int maxIter = 100, double eps = 0.001, int Npts = 100, int Mpts = 30, TCanvas *tc =0, int rate = 10){
  double L = 0;
  double Vin = -100;
  double Vout = 100;
  int maxgraphlines = 200;
  vector<vector<double>> V(Npts,vector<double> (Mpts,0));
  double deltaR = 2.0/(2.0*V.size()+1);
  double deltaP = 2.0*M_PI/V[0].size();
  int rstart = int(RSTART/deltaR);
  int rend = int(REND/deltaR);
  int phiStart = int(PHISTART/deltaP);
  int phiEnd = int(PHIEND/deltaP);
  for( int i = 0; i<Mpts;i++){
    V[Npts-1][i] = 0;//creating that box for grounded B.C. conditions
  }
  for(int j = 0; j<Mpts; j++){
    if( j>= phiStart && j <= phiEnd){
      continue;
    } else {
    V[rstart][j] = Vin;
    V[rend][j] = Vout;
    }
  }
  int msec = 1000/rate;
  TBox *plotRange = new TBox(-1.1*L,-1.1*L,1.1*L,1.1*L);
  TGraph2D *tgV = new TGraph2D();
  if (Npts<50) tgV->SetLineWidth(3);                         
  tgV->SetLineColor(kRed);
  tgV->SetNpx(std::min(maxgraphlines,Npts)); 
  tgV->SetNpy(std::min(maxgraphlines,Npts)); 
  tgV->SetTitle("Voltage;x;y;V");
  
  double dV;
  int niter=0;
  do{
    //printLattice(V);
    dV=iterateJ(V,L);   // iterate using Jacobi method
    //dV=iterateGS(V);   // iterate using Gauss-Seidel method
    ++niter;
    if (tc) {
      tc->cd();
      fillGraph(tgV,V,deltaR, deltaP,plotRange);
      tgV->Draw("surf");
      tc->Update();
      gSystem->Sleep(msec);
    }
  } while (dV>eps && niter<maxIter);
  
  cout << "Ended calculation with " << niter << " iterations, dVmax = " << dV << endl;
 
  fillGraph(tgV,V,deltaR, deltaP,plotRange);
  return tgV;
}









void usage(char *prog){
  std::cerr << "Usage: " << prog << " <option(s)> SOURCES"
	    << "Options:\n"
	    << "\t-h\t\tShow this help message\n"
	    << "\t-a\t\tDisplay animation of solution"
    	    << "\t-I\t\t(max) Number of iterations [100]"
	    << "\t-e\t\tconvergence criteria [0.001]"
    	    << "\t-N\t\tNumber of points in x,y [100]"
	    << "\t-R\t\tmax frames/second with animation [10]"
	    << std::endl;
  exit(0);
}


int main(int argc, char *argv[]){
  TApplication theApp("App", &argc, argv, NULL, -1);  // -1 disables ROOT arg processing

  // defaults for LaplaceLine
  int maxIter=100;
  double eps=0.001;
  int Npts=100;
  TCanvas *tc=0;
  int rate=10;
  
  int opt;
  while ((opt = getopt(argc, argv, "haI:e:N:r:")) != -1) {
    switch (opt) {
    case 'h':
      usage(argv[0]);
      break;
    case 'a':
      tc=new TCanvas();
      break;
    case 'I':
      maxIter=atoi(optarg);
      break;
     case 'e':
      eps=atof(optarg);
      break; 
    case 'N':
      Npts=atoi(optarg);
      break;
    case 'r':
      rate=atoi(optarg);
      break;
    }
  }
 
  auto tg=LaplaceLine(maxIter,eps,Npts,Mpts,tc,rate);

  // display final result
  if (!tc) tc=new TCanvas();
  tg->Draw("surf");              // explore other drawing options!
  
  cout << "Press ^c to exit" << endl;
  theApp.SetIdleTimer(30,".q");  // set up a failsafe timer to end the program  
  theApp.Run();
}
